import numpy as np
import matplotlib.pyplot as plt

def euler_f(v_x,v_y):
    
    k = 0.1
    m = 10
    g = 9.8
    
    A = np.array([[-k/m,0,0,0],[0,-k/m,0,0],[1,0,0,0],[0,1,0,0]]) # differentiation matrix
    f = np.array([0,-g,0,0])
    state_vector = np.array([v_x,v_y,0,0]) #speed c, speed y, x loc, y loc
    print(state_vector)
    x_points = np.array([])
    y_points = np.array([])
    counter = 5
    itera = 0
    while   state_vector[3] >= -1 :
        itera += 1
        t = 0.01
        x_points = np.append(x_points,state_vector[2])

        y_points = np.append(y_points, state_vector[3])
        # This matrix computes euler forward for coordinate and velocity in x,y
        euler_matrix = np.array([[1-t*k/m,0,0,0],
                                 [0,1-t*k/m,0,0],
                                 [t,0,1,0],
                                 [0,t,0,1]])
        state_vector = np.matmul(euler_matrix,state_vector) + t*f 
        print(state_vector)
        counter = counter -1 

    
    return x_points, y_points, itera


def euler_b(v_x,v_y):
    
    k = 0.1
    m = 10
    g = 9.8
    
    A = np.array([[-k/m,0,0,0],[0,-k/m,0,0],[1,0,0,0],[0,1,0,0]]) # differentiation matrix
    f = np.array([0,-g,0,0])
    state_vector = np.array([v_x,v_y,0,0]) #speed c, speed y, x loc, y loc
    print(state_vector)
    x_points = np.array([])
    y_points = np.array([])
    counter = 5
    itera = 0
    while   state_vector[3] >= -1 :
        itera += 1
        t = 0.01
        x_points = np.append(x_points,state_vector[2])
        y_points = np.append(y_points, state_vector[3])
        # This matrix computes euler backward for coordinate and velocity in x,y
        euler_matrix = np.array([[1/(1+t*k/m),0,0,0],
                                 [0,1/(1+t*k/m),0,0],
                                 [t/(1+t*k/m),0,1,0],
                                 [0,t/(1+t*k/m),0,1]])
        state_vector = np.matmul(euler_matrix,state_vector) + t*f 
        print(state_vector)
        counter = counter -1 

    
    return x_points, y_points, itera



"""
euler backward:
x_1 = x + t * (v_x+1)
v_x+1 = v_x + t(a_x+1)
a_x+1 = -k/m*v_x+1

=>

v_x+1 = v_x + t (-k/m * v_x+1)
= v_x+1 + t*k *vx_+1 /m = v_x
v_x+1 * (1 + t*k/m) = v_x
v_x+1 = v_x/(1+t*k/m)

x_1 = x + t * (v_x/(1+t*k/m)) 

"""

x,y, itera = euler_b(9.8, 9.8)

plt.plot(x,y)
